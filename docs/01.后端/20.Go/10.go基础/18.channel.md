---
title: channel
date: 2022-03-27 20:25:52
permalink: /pages/f00afb/
categories:
    - 后端
    - Go
    - go基础
tags:
    - null
---

## channel

`goroutine`和`goroutine`之间的通道就是`channel`。

定义一个`channel`

```go
var c chan int // 此时的 c == nil 不可以进行使用
```

所以还是推荐使用`make`来进行创建`channel`

```go
c := make(chan int)
```

记住第一句话，`channel`是用于`goroutine`和`goroutine`之间的通信的，如果用在和别的地方进行发送数据，就会产生`panic`。

发送数据使用`<-`符号来进行发送。

:::danger

没有`->`这个符号！

:::

-   接收数据，变量在`<-`左边，

-   发送数据，变量或值在`<-`右边

`channel`和函数也是属于同一类级别的，既可以做参数，也可以做返回值。

```go
package main

import (
	"fmt"
	"time"
)

// 表明 此方法是用来发数据的，如果试图去收数据就不对了
func createWorker(id int) chan<- int {
	c := make(chan int)

    // 真正的worker
	go func() {
		for {
			fmt.Printf("Worker %d received %c\n", id, <-c)
		}
	}()

	// 会立刻就返回
	return c
}

func chanDemo() {
    // 只能用于收数据
	var channels [10]chan<- int
	for i := 0; i < 10; i++ {
		channels[i] = createWorker(i)
	}

	for i := 0; i < 10; i++ {
		channels[i] <- 'a' + i
	}

	for i := 0; i < 10; i++ {
		channels[i] <- 'A' + i
	}

	time.Sleep(time.Millisecond)
}

func main() {
	chanDemo()
}

```

**而且我们发数据，也必须要有一个人来收数据，否则也会报错。**

### 加缓冲区

```go
func worker(id int, c chan int)  {
	for {
		fmt.Printf("Worker %d received %d\n", id, n)
	}
}
```

```go
func bufferedChannel() {
   // 3: 缓冲区
   c := make(chan int, 3)

   go worker(0, c)

   c <- 'a'
   c <- 'b'
   c <- 'c'
   c <- 'd'

   time.Sleep(time.Millisecond)
}
```

> 不带缓冲区的 chan 线程写入时会立马发生阻塞，直到有其他线程有对该 chan 执行接收操作且接收成功后，写入的进程才会解除阻塞。
> 不带缓冲区的 chan 线程接收时也会立马发生阻塞，直到有其他线程对该 chan 执行写入操作后，接收的线程才会解除阻塞。

### 带缓冲区的 channel:

-   写入阻塞条件:缓冲区满
-   取出阻塞条件：缓冲区没有数据

### 不带缓冲区的 channel:

-   写入阻塞条件:同一时间没有另外一个线程对该 chan 进行读操作
-   取出阻塞条件:同一时间没有另外一个线程对该 chan 进行取操作

### 主动通知另外一个 goroutine 进行关闭

```go
func channelClose() {
	c := make(chan int)

	go worker(0, c)

	c <- 'a'
	c <- 'b'
	c <- 'c'
	c <- 'd'

	// 告诉接收方发完了
	close(c)

	time.Sleep(time.Millisecond)
}
```

接收方进行判断的两种方式：

```go
func worker(id int, c chan int)  {
	for {
		n, ok := <-c
		if !ok {
			break
		}
		fmt.Printf("Worker %d received %d\n", id, n)
	}
}
```

```go
func worker(id int, c chan int)  {
	// 等到c发完就跳出来
	for n:= range c {
		fmt.Printf("Worker %d received %d\n", id, n)
	}
}
```

如果发送方，不主动关闭，接收方还加判断：

```go
func chanDemo() {
	//var c chan int	// c == nil
	var channels [10]chan<- int
	for i := 0; i < 10; i++ {
		channels[i] = createWorker(i)
	}

	for i := 0; i < 10; i++ {
		channels[i] <- 'a' + i
	}

	for i := 0; i < 10; i++ {
		channels[i] <- 'A' + i
	}

	time.Sleep(time.Millisecond)
}
```

调用这个函数，接收方还是会不断的在进行打印输出，但是会在这个发送方时间到了的时候也会进行断掉。所以接收方加不加无所谓，主要还是取决于发送方。

### 理论基础

**Communication Sequentital Process**，简称 CSP 模型。

`Don't communicate by sharing memory;share memory by communicating.`

> 不要通过共享内存来通信；通过通信来共享内存。

[https://www.jianshu.com/p/36e246c6153d](https://www.jianshu.com/p/36e246c6153d)

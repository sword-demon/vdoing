---
title: error错误处理
date: 2022-03-25 21:57:17
permalink: /pages/53f980/
categories:
    - 后端
    - Go
    - go基础
tags:
    - null
---

## error 处理一

我们先来造出来一个`error`

```go
func writeFile(filename string) {
	// 打开一个文件
	file, err := os.OpenFile(filename, os.O_EXCL|os.O_CREATE, 0666)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	// 先写到内存里
	writer := bufio.NewWriter(file)
	// 刷到硬盘里
	defer writer.Flush()

	f := fib()
	for i := 0; i < 20; i++ {
		_, err := fmt.Fprintln(writer, f())
		if err != nil {
			return
		}
	}
}
```

`O_EXCL`如果存在这个文件，我们现在会打开不了

```bash
panic: open fib.txt: file exists

goroutine 1 [running]:
main.writeFile({0x10a3f0d, 0xc0000001a0})

```

程序会挂掉。

加一段处理代码

```go
func writeFile(filename string) {
	// 打开一个文件
	file, err := os.OpenFile(filename, os.O_EXCL|os.O_CREATE, 0666)
	if err != nil {
		fmt.Println("file already exist")
        // 程序挂掉，这里就应该结束 return 返回
		return
	}
	defer file.Close()

	// 先写到内存里
	writer := bufio.NewWriter(file)
	// 刷到硬盘里
	defer writer.Flush()

	f := fib()
	for i := 0; i < 20; i++ {
		_, err := fmt.Fprintln(writer, f())
		if err != nil {
			return
		}
	}
}
```

我们可以点开`OpenFile`源码，查看返回值类型，为`(*File, error)`，我们再点击`error`进去找到源码：`builtin.go`

```go
// The error built-in interface type is the conventional interface for
// representing an error condition, with the nil value representing no error.
type error interface {
	Error() string
}
```

它会获得一个错误的字符串消息

```go
if err != nil {
    fmt.Println("Error: ",err.Error())
    return
}
```

他会帮我们打印出错误信息。

我们再回过头看`OpenFile`的一些源码信息：

```go
// If there is an error, it will be of type *PathError.
func OpenFile(name string, flag int, perm FileMode) (*File, error) {
	testlog.Open(name)
	f, err := openFileNolog(name, flag, perm)
	if err != nil {
		return nil, err
	}
	f.appendMode = flag&O_APPEND != 0

	return f, nil
}
```

看到注释的地方，它如果出错，会变成`*PathError`类型，我们再针对这个错误进行处理错误

```go
if err != nil {
    if pathError, ok := err.(*os.PathError); !ok {
        panic(err)
    } else {
        fmt.Println(pathError.Op, pathError.Path, pathError.Err)
    }
    return
}
```

我们也可以自己定义`error`的内容

```go
err = errors.New("this is a custom error")
```

如果程序没有匹配到`pathError`，则会`panic`出这个信息。

当然，因为`error`的源码为`interface`，我们可以自己去实现接口，我们可以自己定义一些`error`的类型。

## 错误处理二

写一个`web`获取文件的案例代码

```go
package main

import (
	"io/ioutil"
	"net/http"
	"os"
)

func main() {
	http.HandleFunc("/list/",
		func(writer http.ResponseWriter, request *http.Request) {
			path := request.URL.Path[len("/list/"):] // /list/fib.txt
			file, err := os.Open(path)
			if err != nil {
				panic(err)
			}
			defer file.Close()

			all, err := ioutil.ReadAll(file)
			if err != nil {
				panic(err)
			}

			writer.Write(all)
		})

	err := http.ListenAndServe(":8888", nil)
	if err != nil {
		panic(err)
	}
}

```

我们输入:`localhost:8888/list/fib.txt`进行访问

![结果](https://raw.githubusercontent.com/sword-demon/img/master/img/20220325221705.png)

结果：

```
1
1
2
3
5
8
13
21
34
55
89
144
233
377
610
987
1597
2584
4181
6765
```

但是我们总归是会出现输入错误的链接的时候，我们假装输入错误一下，就会出现错误。

```bash
2022/03/25 22:46:04 http: panic serving [::1]:56670: open fib.txta: no such file or directory
goroutine 43 [running]:
net/http.(*conn).serve.func1()

```

但是，这边`http`服务还没`die`掉，这边会有一个保护措施。

我们进行改进

```go
func main() {
	http.HandleFunc("/list/",
		func(writer http.ResponseWriter, request *http.Request) {
			path := request.URL.Path[len("/list/"):] // /list/fib.txt
			file, err := os.Open(path)
			if err != nil {
				http.Error(writer, err.Error(), http.StatusInternalServerError)
				return
			}
			defer file.Close()

			all, err := ioutil.ReadAll(file)
			if err != nil {
				panic(err)
			}

			writer.Write(all)
		})

	err := http.ListenAndServe(":8888", nil)
	if err != nil {
		panic(err)
	}
}

```

再次访问错误链接，出现以下结果：

```
open fib.txta: no such file or directory
```

但是这种很明显的这种错误信息，我们不应该暴露给外部看到，我们应该有一个地方进行包装一下这些错误消息。

我们将这段业务逻辑分离出来。

`/filelisting/handler.go`

```go
package filelisting

import (
	"io/ioutil"
	"net/http"
	"os"
)

func HandlerFileList(writer http.ResponseWriter, request *http.Request) error {
	path := request.URL.Path[len("/list/"):] // /list/fib.txt
	file, err := os.Open(path)
	if err != nil {
		return err
	}
	defer file.Close()

	all, err := ioutil.ReadAll(file)
	if err != nil {
		return err
	}

	writer.Write(all)
	return nil
}

```

这里业务逻辑专注于进行业务逻辑的处理，我们只要将错误进行返回，抛给别人去处理即可。

我们为了方便处理，我们定义一个该方法的类型的结构体

`main.go`

```go
type appHandler func(writer http.ResponseWriter, request *http.Request) error
```

封装一个处理错误的函数，这个是一个函数式编程，输入也是函数，输出也是函数。

```go
func errWrapper(handler appHandler) func(http.ResponseWriter, *http.Request) {
	return func(writer http.ResponseWriter, request *http.Request) {
		err := handler(writer, request)
		if err != nil {
			code := http.StatusOK
			switch  {
			// 文件不存在的错
			case os.IsNotExist(err):
				// 向 writer 汇报错误 你的东西 找不到
				code = http.StatusNotFound
			default:
				code = http.StatusInternalServerError
			}
			http.Error(writer, http.StatusText(code), code)
		}
	}
}
```

```go
func main() {
	http.HandleFunc("/list/", errWrapper(filelisting.HandlerFileList))

	err := http.ListenAndServe(":8888", nil)
	if err != nil {
		panic(err)
	}
}
```

此时再重新运行服务，再次输入错误链接，页面出现`Not Found`简单的提示信息，这个就是一个非常普通的一个错误。

![结果](https://raw.githubusercontent.com/sword-demon/image_store/master/blog/20220325233032.png)

我们还是有必要进行加上日志记录，仅仅是页面上提示，我们最终还是要知道发生什么错误的

```go
log.Printf("Err Handling request: %s", err.Error())
```

```
2022/03/25 23:27:07 Err Handling request: open fib.txta: no such file or directory

```

最后我们还加了一个文件是否有权限访问的判断：

```go
package main

import (
	"learngo/errhandling/filelisteningserver/filelisting"
	"log"
	"net/http"
	"os"
)

type appHandler func(writer http.ResponseWriter, request *http.Request) error

func errWrapper(handler appHandler) func(http.ResponseWriter, *http.Request) {
	return func(writer http.ResponseWriter, request *http.Request) {
		err := handler(writer, request)
		if err != nil {
			log.Printf("Err Handling request: %s", err.Error())
			code := http.StatusOK
			switch  {
			// 文件不存在的错
			case os.IsNotExist(err):
				// 向 writer 汇报错误 你的东西 找不到
				code = http.StatusNotFound
			case os.IsPermission(err):
				code = http.StatusForbidden
			default:
				code = http.StatusInternalServerError
			}
			http.Error(writer, http.StatusText(code), code)
		}
	}
}

func main() {
	http.HandleFunc("/list/", errWrapper(filelisting.HandlerFileList))

	err := http.ListenAndServe(":8888", nil)
	if err != nil {
		panic(err)
	}
}

```

---
title: C编译和链接过程
date: 2022-04-17 23:09:46
permalink: /pages/9e0a2b/
categories:
    - 后端
    - C&C++
tags:
    - null
---

# C 编译、链接过程

## `extern`和`static`的作用

### `static`

#### 1. 修饰函数

> `static`修饰函数时表示，该函数只在本文件有效，也就是只能被本文件的其他函数调，其他文件不能调用(引用)。

`a.c`

```c
int func1(void)
{
    func(100); // 不能引用
}
```

`b.c`

```c
static void func(int stu_num)
{
    // .....
}
```

`static`就像是一把锁，把函数`func`的有效范围锁在了`b.c`其他`.c`看不见这个函数 ，自然无法调用。

:::tip

因为`static`将函数名这个符号变成了“本地符号”，“本地符号”只在本文件可见，其他文件是看不见的。

:::

#### 2. 修饰变量

1.  `static`修饰局部变量

    > 改变的是局部变量的存储位置，从栈变为静态存储区，与“本地符号”什么的没有关系

    ```c
    int func(int va)
    {
        int a;
        int b = 10;

        // ...
    }
    ```

    `a、b`为“自动局部变量”，空间开辟于栈中。

    加了`static`修饰

    ```c
    int func(int va)
    {
        static int a;
        static int b = 10;

        // ...
    }
    ```

    `a、b`变为了“静态局部变量”，`a、b`的空间开辟于静态存储区，而不再是栈。

    -   如果没有初始化的话，比如`a`就没有初始化，`a`的空间在静态区中的`.bss`区
    -   如果有初始化的话，比如`b`就有初始化，`b`的空间在静态区中的`.data`区

2.  `static`修饰全局变量

    > 与修饰函数一样，让全局变量只在本文件有效，其它文件无法引用。
    >
    > `static`修饰全局变量的时候，与全局变量的存储位置无关，全局变量的空间本来就是在静态存储区，加不加`static`并不能改变存储位置，`static`只是改变了符号的属性，变成了本地符号。

### `extern`

#### 1. 修饰函数

> `extern`修饰的函数，表示除了能被本文件引用外，还可以被其他的文件引用，在其他文件中是可见的，只不过在其他文件中引用时，需要做声明。刚好与`static`相反。

`a.c`

```c
extern void func(int stu_num);

extern int a_fun(void)
{
    fun(100);
}
```

`b.c`

```c
extern void fun(int stu_num)
{
    // ...
}
```

事实上，`extern`不需要明确写出，因为默认是`extern`的，也就是说定义和声明可以写出如下格式：

```c
void func(int stu_num);

int a_fun(void)
{
    fun(100);
}
```

```c
void fun(int stu_num)
{
    // ...
}
```

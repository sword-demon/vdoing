---
title: 分布式事务
date: 2021-10-25 00:04:25
permalink: /pages/1dd061/
categories:
    - 技术
    - 架构设计
tags:
    - null
---

## 分布式事务

讲到事务，基本就是经典的转账问题

支付宝账户表：`A(id, user_id, amount)`

余额宝账户表：`B(id, user_id, amount)`

用户的`user_id = 1`，从支付宝转账 1 万到余额宝分为 2 个步骤：

1.  支付宝表扣除 1 万：

    ```sql
    update A set amount = amount - 10000 where user_id = 1;
    ```

2.  余额宝表增加 1 万：

    ```sql
    update B set amount = amount + 10000 where user_id = 1;
    ```

**如何保证一致性呢？**

> 单个数据库，我们保证`ACID`使用数据库事务

---

随着系统变大，进行了微服务架构的改造，因为每个微服务独占了一个数据库实例，从`user_id = 1`发起的转账动作，跨越了两个微服务：`pay`和`balance`服务。

我们需要保证，跨多个服务的步骤数据一致性：

1.  微服务`pay`的支付宝表扣除 1 万
2.  微服务`balance`的余额宝的表增加 1 万

> 每个系统都对应一个独立的数据源，且可能位于不同机房，同时调用多个服务很难保证同时成功，这就是跨服务分布式事务的问题。

:::tip

我们系统应该能保证每个服务自身的`ACID`，基于这个假设，我们事务消息解决分布式事务的问题。

:::

### 事务消息

:::tip

在很多的麻辣烫的店，你点了份麻辣烫并付了钱，他们并不会直接把你点的东西给你，而是给你一个类似号码的手串给你，然后让你拿着号码牌到出货区排队去取。

为什么餐饮店要将付钱和取货 2 个动作分开呢？原因很多，其中一个很重要的原因是为了使他们的接待能力增加(程序里的说法就是并发量更高)。

只要这张号码牌在，你最终是能拿到麻辣烫的。同理，转账服务也是如此。

:::

> 当支付宝账户扣除 1 万元后，我们只要生成一个凭证(消息)即可，这个凭证(消息)上写着要余额宝增加 1 万，只要这个消息能可靠的保存，我们最终是可以拿到这个凭证(消息)让余额宝账号增加 1 万的，即我们能依靠这个凭证(消息)完成最终一致性。

### 如何保存可靠的消息凭证

> 要解决消息可靠存储，实际上需要解决的是本地的`mysql`存储和`message`存储的一致性问题。

解决办法：

-   `Transactional outbox`
-   `Polling publisher`
-   `Transaction log tailing`
-   `2PC Message Queue`

**事务消息一旦被可靠的持久化，我们整个分布式事务，便完成了最终一致性，消息的消费才能保障最终业务数据的完整性，所以我们要尽最大努力，把消息送达到下游的业务消费方，成为`Best Effort`。只有消息被消费，整个交易才能算是完整完结。**

## 待完结

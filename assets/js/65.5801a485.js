(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{506:function(t,e,a){"use strict";a.r(e);var r=a(16),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"简述-go-协程调度机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简述-go-协程调度机制"}},[t._v("#")]),t._v(" 简述 Go 协程调度机制")]),t._v(" "),a("h2",{attrs:{id:"参考文章"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://medium.com/@ankur_anand/illustrated-tales-of-go-runtime-scheduler-74809ef6d19b",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://medium.com/@ankur_anand/illustrated-tales-of-go-runtime-scheduler-74809ef6d19b(需要科学上网)"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://lessisbetter.site/2019/03/10/golang-scheduler-1-history/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://lessisbetter.site/2019/03/10/golang-scheduler-1-history/(这个不错)"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/27056944",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://zhuanlan.zhihu.com/p/27056944(知乎的一篇文章)"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"真正干活的是线程-m"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#真正干活的是线程-m"}},[t._v("#")]),t._v(" 真正干活的是线程 M")]),t._v(" "),a("blockquote",[a("p",[t._v("OS 提供的线程："),a("code",[t._v("M")])])]),t._v(" "),a("h2",{attrs:{id:"协程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协程"}},[t._v("#")]),t._v(" 协程")]),t._v(" "),a("p",[t._v("是用户态的线程，是“用户”创建的，通常用"),a("code",[t._v("G")]),t._v("表示，协程自己不会运行，Go 有一个协程调度机制。")]),t._v(" "),a("ul",[a("li",[t._v("G(goroutine)：代表携程")]),t._v(" "),a("li",[t._v("M（Work Thread）：代表线程")]),t._v(" "),a("li",[t._v("P(Processor)，代表处理器核(CPU 核)，又称上下文，不超过机器本身的"),a("code",[t._v("GOMAXPROCS")])])]),t._v(" "),a("ol",[a("li",[t._v("运行的 M 都必须绑定一个 P，一次只能绑定一个")]),t._v(" "),a("li",[t._v("P 保存着一个协程 G 的队列【本地队列】")]),t._v(" "),a("li",[t._v("调度器还拥有一个全局的 G 队列【全局队列】")]),t._v(" "),a("li",[t._v("M 从队列中提取 G，并执行")])]),t._v(" "),a("h2",{attrs:{id:"找-g-的顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#找-g-的顺序"}},[t._v("#")]),t._v(" 找 G 的顺序")]),t._v(" "),a("ol",[a("li",[a("p",[a("code",[t._v("1/61")]),t._v("的几率在全局队列中找 G，"),a("code",[t._v("60/61")]),t._v("的几率在本地队列找 G")])]),t._v(" "),a("li",[a("p",[t._v("如果全局队列找不到 G，就从 P 的本地队列里找 G")])]),t._v(" "),a("li",[a("p",[t._v("如果找不到，就从其他 P 的本地队列里“窃取”P")])]),t._v(" "),a("li",[a("p",[t._v("如果找不到，则从全局队列中拿取一部分 G 到本地队列，这里拿取的“一部分”满足一个公式：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])])])]),t._v(" "),a("h2",{attrs:{id:"阻塞过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#阻塞过程"}},[t._v("#")]),t._v(" 阻塞过程")]),t._v(" "),a("blockquote",[a("p",[t._v("假设 G1 阻塞，从而造成 M1 阻塞")])]),t._v(" "),a("ol",[a("li",[t._v("P1 第一件事就是和 M1 解绑")]),t._v(" "),a("li",[t._v("然后 M1 和 G1 依然保持关系")]),t._v(" "),a("li",[t._v("阻塞结束，M1 寻找 P【不一定是原来的 P1】来接收 G1，如果找不到，扔给全局队列")])]),t._v(" "),a("h2",{attrs:{id:"自旋"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自旋"}},[t._v("#")]),t._v(" 自旋")]),t._v(" "),a("p",[t._v("M 在本地队列、全局队列都找不到 G，则会进入自旋【有条件：如 2M < 繁忙的 P，即当 M 的数量的 2 倍小于繁忙的 P 就会进入自旋】")]),t._v(" "),a("blockquote",[a("p",[t._v("自旋：可以理解为循环执行某个代码块，从而不仅如此休眠，当然会耗费一些 CPU；")]),t._v(" "),a("p",[a("strong",[t._v("但是比起反复启动新的 M 要性能高")])])]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("blockquote",[a("p",[t._v("Go 的协程调度就是：P 将 G 合理的分配给某个 M 的过程。")])])])}),[],!1,null,null,null);e.default=s.exports}}]);